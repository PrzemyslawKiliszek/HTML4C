<!doctype html>
<html lang="de">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ChiralitÔøΩÔøΩt Erkennungs-Spiel</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .game-container {
      width: 100%;
      min-height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .header {
      background: white;
      padding: 1.5rem 2rem;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      margin-bottom: 2rem;
      text-align: center;
      width: 90%;
      max-width: 1000px;
    }
    
    .header h1 {
      margin: 0 0 1rem 0;
      font-size: 2rem;
      color: #2d3748;
    }
    
    .phase-indicator {
      background: #667eea;
      color: white;
      padding: 0.5rem 1.5rem;
      border-radius: 20px;
      font-weight: bold;
      display: inline-block;
      margin-bottom: 1rem;
    }
    
    .instructions {
      color: #4a5568;
      font-size: 1.1rem;
      line-height: 1.6;
    }
    
    .molecule-section {
      background: white;
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      margin-bottom: 2rem;
      width: 90%;
      max-width: 600px;
    }
    
    .molecule-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: #2d3748;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .molecule-display {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 320px;
      padding: 1.5rem;
      border: 3px solid #667eea;
      border-radius: 12px;
      background: #f7fafc;
      margin-bottom: 1.5rem;
      perspective: 1000px;
    }
    
    .answer-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .answer-btn {
      padding: 1rem 2rem;
      font-size: 1.1rem;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #667eea;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      min-width: 130px;
    }
    
    .answer-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      background: #5a67d8;
    }
    
    .answer-btn:active {
      transform: translateY(0);
    }
    
    .comparison-section {
      background: white;
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      width: 90%;
      max-width: 1200px;
      margin-bottom: 2rem;
    }
    
    .comparison-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: #2d3748;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .comparison-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 1.5rem;
    }
    
    .comparison-molecule {
      border: 3px solid #48bb78;
      border-radius: 12px;
      padding: 1rem;
      background: #f7fafc;
    }
    
    .comparison-label {
      font-weight: bold;
      font-size: 1.2rem;
      color: #2d3748;
      text-align: center;
      margin-bottom: 1rem;
    }
    
    .comparison-display {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 280px;
      perspective: 1000px;
    }
    
    .rotating {
      animation: rotate3d 0.8s ease-in-out;
    }
    
    .flipping {
      animation: flip3d 0.8s ease-in-out;
    }
    
    @keyframes rotate3d {
      0% {
        transform: rotateY(0deg);
      }
      100% {
        transform: rotateY(180deg);
      }
    }
    
    @keyframes flip3d {
      0% {
        transform: rotateZ(0deg);
      }
      50% {
        transform: rotateZ(90deg) scale(0.8);
      }
      100% {
        transform: rotateZ(180deg);
      }
    }
    
    .transform-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 1rem;
    }
    
    .transform-btn {
      padding: 0.6rem 1.2rem;
      font-size: 0.9rem;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #764ba2;
      color: white;
      transition: all 0.3s ease;
    }
    
    .transform-btn:hover {
      background: #5a3880;
      transform: scale(1.05);
    }
    
    .feedback {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      width: 90%;
      max-width: 800px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .feedback.correct {
      background: #c6f6d5;
      color: #22543d;
      border: 3px solid #48bb78;
    }
    
    .feedback.incorrect {
      background: #fed7d7;
      color: #742a2a;
      border: 3px solid #f56565;
    }
    
    .feedback h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.4rem;
    }
    
    .feedback p {
      margin: 0.5rem 0;
      font-size: 1rem;
      line-height: 1.5;
    }
    
    .continue-btn {
      padding: 1rem 2rem;
      font-size: 1.1rem;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      background: #48bb78;
      color: white;
      margin-top: 1.5rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
    }
    
    .continue-btn:hover {
      background: #38a169;
      transform: scale(1.05);
    }
    
    .success-message {
      background: #c6f6d5;
      border: 3px solid #48bb78;
      color: #22543d;
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      margin-top: 1.5rem;
      font-size: 1.2rem;
      font-weight: bold;
      animation: celebrate 0.5s ease-in-out;
    }
    
    @keyframes celebrate {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @media (max-width: 768px) {
      .comparison-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="game-container">
   <div class="header">
    <h1 id="game-title">Chiralit√§t Erkennungs-Spiel</h1>
    <div class="phase-indicator" id="phase-indicator">
     Phase 1: Chiralit√§t erkennen
    </div>
    <p class="instructions" id="instructions">Ist dieses Molek√ºl chiral (hat ein Chiralit√§tszentrum) oder achiral?</p>
   </div>
   <div id="content-area"></div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "Chiralit√§t Erkennungs-Spiel",
      phase1_instruction: "Ist dieses Molek√ºl chiral (hat ein Chiralit√§tszentrum) oder achiral?",
      phase2_instruction_enantiomers: "Diese beiden Molek√ºle sind Enantiomere (Spiegelbildisomere). Versuche sie durch Drehen oder Spiegeln zur Deckung zu bringen!",
      phase2_instruction_identical: "Diese beiden Darstellungen zeigen das gleiche Molek√ºl. Bringe sie durch Transformationen zur Deckung!",
      chiral_button: "Chiral",
      achiral_button: "Achiral",
      rotate_button: "‚Üª Drehen",
      mirror_button: "ü™û An Oberfl√§che spiegeln",
      primary_color: "#667eea",
      secondary_color: "#764ba2",
      success_color: "#48bb78"
    };

    const gameState = {
      phase: 1,
      currentMolecule: null,
      userAnswer: null,
      moleculeA: { rotated: false, mirrored: false },
      moleculeB: { rotated: false, mirrored: false }
    };

    // Chirale Molek√ºle mit 4 unterschiedlichen Substituenten
    const molecules = [
      // 2-Butanol (chiral)
      {
        name: "2-Butanol",
        isChiral: true,
        center: { x: 175, y: 160 },
        groups: [
          { name: "OH", pos: "top", color: "#e53e3e" },
          { name: "H", pos: "front", color: "#cbd5e0" },
          { name: "CH3", pos: "left", color: "#2d3748" },
          { name: "C2H5", pos: "right", color: "#2d3748" }
        ]
      },
      // Bromchlorfluormethan (chiral)
      {
        name: "CHBrClF",
        isChiral: true,
        center: { x: 175, y: 160 },
        groups: [
          { name: "Br", pos: "top", color: "#9c4221" },
          { name: "H", pos: "front", color: "#cbd5e0" },
          { name: "Cl", pos: "left", color: "#38a169" },
          { name: "F", pos: "right", color: "#5a67d8" }
        ]
      },
      // Milchs√§ure (chiral)
      {
        name: "Milchs√§ure",
        isChiral: true,
        center: { x: 175, y: 160 },
        groups: [
          { name: "OH", pos: "top", color: "#e53e3e" },
          { name: "H", pos: "front", color: "#cbd5e0" },
          { name: "CH3", pos: "left", color: "#2d3748" },
          { name: "COOH", pos: "right", color: "#d69e2e" }
        ]
      },
      // Propan (achiral - zwei gleiche H)
      {
        name: "Propan",
        isChiral: false,
        center: { x: 175, y: 160 },
        groups: [
          { name: "H", pos: "top", color: "#cbd5e0" },
          { name: "H", pos: "front", color: "#cbd5e0" },
          { name: "CH3", pos: "left", color: "#2d3748" },
          { name: "CH3", pos: "right", color: "#2d3748" }
        ]
      },
      // 2,2-Dichlorpropan (achiral - zwei gleiche Cl)
      {
        name: "2,2-Dichlorpropan",
        isChiral: false,
        center: { x: 175, y: 160 },
        groups: [
          { name: "Cl", pos: "top", color: "#38a169" },
          { name: "Cl", pos: "front", color: "#38a169" },
          { name: "CH3", pos: "left", color: "#2d3748" },
          { name: "CH3", pos: "right", color: "#2d3748" }
        ]
      }
    ];

    function createTetrahedralMolecule(groups, rotated, mirrored) {
      // Positionen f√ºr tetraedrische Geometrie
      const positions = {
        top: { x: 175, y: 90, bond: { x1: 175, y1: 160, x2: 175, y2: 100 } },
        front: { x: 175, y: 230, bond: { x1: 175, y1: 160, x2: 175, y2: 220 } },
        left: { x: 100, y: 160, bond: { x1: 175, y1: 160, x2: 110, y2: 160 } },
        right: { x: 250, y: 160, bond: { x1: 175, y1: 160, x2: 240, y2: 160 } }
      };

      let groupArray = [...groups];

      // Transformationen anwenden
      if (rotated) {
        // 180¬∞ Drehung: vorne ‚Üî hinten, links ‚Üî rechts
        const temp = [...groupArray];
        groupArray = groupArray.map(g => {
          if (g.pos === 'top') return { ...temp.find(x => x.pos === 'front'), pos: 'top' };
          if (g.pos === 'front') return { ...temp.find(x => x.pos === 'top'), pos: 'front' };
          if (g.pos === 'left') return { ...temp.find(x => x.pos === 'right'), pos: 'left' };
          if (g.pos === 'right') return { ...temp.find(x => x.pos === 'left'), pos: 'right' };
          return g;
        });
      }

      if (mirrored) {
        // Spiegelung an Oberfl√§che: oben ‚Üî unten (front ‚Üî top), Keilstrich wechselt Position
        const temp = [...groupArray];
        groupArray = groupArray.map(g => {
          if (g.pos === 'top') return { ...temp.find(x => x.pos === 'front'), pos: 'top' };
          if (g.pos === 'front') return { ...temp.find(x => x.pos === 'top'), pos: 'front' };
          return g;
        });
      }

      let svg = '<svg width="350" height="320" viewBox="0 0 350 320">';
      
      // Zeichne Bindungen
      groupArray.forEach(group => {
        const pos = positions[group.pos];
        const bondType = group.pos === 'front' ? 'wedge' : group.pos === 'top' ? 'dashed' : 'normal';
        
        if (bondType === 'wedge') {
          // Keilbindung (kommt aus der Ebene heraus)
          svg += `<polygon points="${pos.bond.x1},${pos.bond.y1} ${pos.bond.x2-8},${pos.bond.y2} ${pos.bond.x2+8},${pos.bond.y2}" fill="#888" />`;
        } else if (bondType === 'dashed') {
          // Gestrichelte Bindung (geht in die Ebene hinein)
          for (let i = 0; i < 5; i++) {
            const y1 = pos.bond.y1 + i * 12;
            const y2 = y1 + 8;
            svg += `<line x1="${pos.bond.x1}" y1="${y1}" x2="${pos.bond.x2}" y2="${y2}" stroke="#888" stroke-width="2"/>`;
          }
        } else {
          // Normale Bindung
          svg += `<line x1="${pos.bond.x1}" y1="${pos.bond.y1}" x2="${pos.bond.x2}" y2="${pos.bond.y2}" stroke="#888" stroke-width="3"/>`;
        }
      });

      // Zentrales C-Atom
      svg += `<circle cx="175" cy="160" r="16" fill="#444444" stroke="#222" stroke-width="2"/>`;
      svg += `<text x="175" y="167" font-size="18" font-weight="bold" fill="white" text-anchor="middle">C</text>`;

      // Zeichne Substituenten (top ist unter der Oberfl√§che - gestrichelt)
      groupArray.forEach(group => {
        const pos = positions[group.pos];
        const isBelowSurface = group.pos === 'top';
        svg += createSubstituent(group.name, pos.x, pos.y, group.color, isBelowSurface);
      });

      svg += '</svg>';
      return svg;
    }

    function createSubstituent(name, x, y, color, isBelowSurface = false) {
      let svg = '';
      const radius = name.length > 2 ? 22 : 18;
      const fontSize = name.length > 3 ? 14 : 16;
      
      // Wenn unter der Oberfl√§che, mache heller und transparenter
      let fillColor = color;
      let opacity = 1;
      if (isBelowSurface) {
        opacity = 0.5;
        // Mache Farbe heller durch Mischen mit wei√ü
        fillColor = lightenColor(color);
      }
      
      svg += `<circle cx="${x}" cy="${y}" r="${radius}" fill="${fillColor}" stroke="#222" stroke-width="2" opacity="${opacity}"/>`;
      svg += `<text x="${x}" y="${y + 5}" font-size="${fontSize}" font-weight="bold" fill="white" text-anchor="middle" opacity="${opacity}">${name}</text>`;
      
      return svg;
    }

    function lightenColor(color) {
      // Einfache Helligkeitserh√∂hung
      if (color === "#cbd5e0") return "#e2e8f0";
      if (color === "#2d3748") return "#4a5568";
      if (color === "#e53e3e") return "#fc8181";
      if (color === "#9c4221") return "#c05621";
      if (color === "#38a169") return "#68d391";
      if (color === "#5a67d8") return "#7f9cf5";
      if (color === "#d69e2e") return "#ecc94b";
      return color;
    }

    function areIdentical(groupsA, groupsB) {
      const sortedA = groupsA.map(g => `${g.name}-${g.pos}`).sort().join(',');
      const sortedB = groupsB.map(g => `${g.name}-${g.pos}`).sort().join(',');
      return sortedA === sortedB;
    }

    function applyTransformations(groups, rotated, mirrored) {
      let result = [...groups];

      if (rotated) {
        result = result.map(g => {
          if (g.pos === 'top') return { ...result.find(x => x.pos === 'front'), pos: 'top' };
          if (g.pos === 'front') return { ...result.find(x => x.pos === 'top'), pos: 'front' };
          if (g.pos === 'left') return { ...result.find(x => x.pos === 'right'), pos: 'left' };
          if (g.pos === 'right') return { ...result.find(x => x.pos === 'left'), pos: 'right' };
          return g;
        });
      }

      if (mirrored) {
        // Spiegelung an Oberfl√§che: oben ‚Üî unten
        const temp = [...result];
        result = result.map(g => {
          if (g.pos === 'top') return { ...temp.find(x => x.pos === 'front'), pos: 'top' };
          if (g.pos === 'front') return { ...temp.find(x => x.pos === 'top'), pos: 'front' };
          return g;
        });
      }

      return result;
    }

    function showPhase1() {
      gameState.phase = 1;
      gameState.currentMolecule = molecules[Math.floor(Math.random() * molecules.length)];
      
      document.getElementById('phase-indicator').textContent = 'Phase 1: Chiralit√§t erkennen';
      document.getElementById('instructions').textContent = 
        window.elementSdk?.config?.phase1_instruction || defaultConfig.phase1_instruction;
      
      const contentArea = document.getElementById('content-area');
      contentArea.innerHTML = `
        <div class="molecule-section">
          <div class="molecule-title">${gameState.currentMolecule.name}</div>
          <div class="molecule-display">
            ${createTetrahedralMolecule(gameState.currentMolecule.groups, false, false)}
          </div>
          <div class="answer-buttons">
            <button class="answer-btn" onclick="checkAnswer(true)">
              ${window.elementSdk?.config?.chiral_button || defaultConfig.chiral_button}
            </button>
            <button class="answer-btn" onclick="checkAnswer(false)">
              ${window.elementSdk?.config?.achiral_button || defaultConfig.achiral_button}
            </button>
          </div>
        </div>
        <div id="feedback-area"></div>
      `;
    }

    function checkAnswer(isChiral) {
      const correct = isChiral === gameState.currentMolecule.isChiral;
      
      const feedbackArea = document.getElementById('feedback-area');
      
      let explanationText = '';
      if (gameState.currentMolecule.isChiral) {
        explanationText = correct ? 
          `Richtig! ${gameState.currentMolecule.name} hat ein Chiralit√§tszentrum mit 4 verschiedenen Substituenten.` :
          `${gameState.currentMolecule.name} ist chiral - es hat 4 verschiedene Substituenten am zentralen C-Atom.`;
      } else {
        explanationText = correct ? 
          `Richtig! ${gameState.currentMolecule.name} ist achiral - es hat mindestens zwei gleiche Substituenten.` :
          `${gameState.currentMolecule.name} ist achiral - mindestens zwei Substituenten sind gleich.`;
      }
      
      feedbackArea.innerHTML = `
        <div class="feedback ${correct ? 'correct' : 'incorrect'}">
          <h3>${correct ? '‚úì Richtig!' : '‚úó Nicht ganz richtig'}</h3>
          <p>${explanationText}</p>
          <button class="continue-btn" onclick="showPhase2()">
            ${gameState.currentMolecule.isChiral ? 'Enantiomere vergleichen' : 'Identit√§t pr√ºfen'}
          </button>
        </div>
      `;
    }

    function showPhase2() {
      gameState.phase = 2;
      gameState.moleculeA = { rotated: false, mirrored: false };
      gameState.moleculeB = { rotated: false, mirrored: false };
      
      document.getElementById('phase-indicator').textContent = 'Phase 2: Deckungsgleichheit testen';
      
      const contentArea = document.getElementById('content-area');
      
      // F√ºr chirale Molek√ºle: Enantiomer erstellen (an Oberfl√§che gespiegelt - oben ‚Üî unten)
      // F√ºr achirale: gleiche Orientierung (nur gedreht)
      const moleculeBGroups = gameState.currentMolecule.isChiral ? 
        applyTransformations(gameState.currentMolecule.groups, false, true) :
        applyTransformations(gameState.currentMolecule.groups, true, false);
      
      window.moleculeBOriginal = moleculeBGroups;
      
      const instruction = gameState.currentMolecule.isChiral ?
        (window.elementSdk?.config?.phase2_instruction_enantiomers || defaultConfig.phase2_instruction_enantiomers) :
        (window.elementSdk?.config?.phase2_instruction_identical || defaultConfig.phase2_instruction_identical);
      
      document.getElementById('instructions').textContent = instruction;
      
      contentArea.innerHTML = `
        <div class="comparison-section">
          <div class="comparison-title">
            ${gameState.currentMolecule.name}: ${gameState.currentMolecule.isChiral ? 'R/S-Enantiomere' : 'Identische Molek√ºle'}
          </div>
          
          <div class="comparison-grid">
            <div class="comparison-molecule">
              <div class="comparison-label">Molek√ºl A</div>
              <div class="comparison-display" id="molecule-a-display">
                ${createTetrahedralMolecule(gameState.currentMolecule.groups, false, false)}
              </div>
              <div class="transform-buttons">
                <button class="transform-btn" onclick="transformMoleculeA('rotate')">
                  ${defaultConfig.rotate_button}
                </button>
                <button class="transform-btn" onclick="transformMoleculeA('mirror')">
                  ${defaultConfig.mirror_button}
                </button>
                <button class="transform-btn" onclick="resetMoleculeA()" style="background: #e53e3e;">
                  Zur√ºcksetzen
                </button>
              </div>
            </div>
            
            <div class="comparison-molecule">
              <div class="comparison-label">Molek√ºl B</div>
              <div class="comparison-display" id="molecule-b-display">
                ${createTetrahedralMolecule(moleculeBGroups, false, false)}
              </div>
              <div class="transform-buttons">
                <button class="transform-btn" onclick="transformMoleculeB('rotate')">
                  ${defaultConfig.rotate_button}
                </button>
                <button class="transform-btn" onclick="transformMoleculeB('mirror')">
                  ${defaultConfig.mirror_button}
                </button>
                <button class="transform-btn" onclick="resetMoleculeB()" style="background: #e53e3e;">
                  Zur√ºcksetzen
                </button>
              </div>
            </div>
          </div>
          
          <div id="result-area"></div>
          
          <div class="feedback" style="background: #fef5e7; border: 3px solid #f39c12; color: #7d4e00;">
            <h3>üî¨ ${gameState.currentMolecule.isChiral ? 'Enantiomere' : 'Identische Molek√ºle'}</h3>
            <p>
              ${gameState.currentMolecule.isChiral ? 
                'Enantiomere sind Spiegelbildisomere, die sich NICHT zur Deckung bringen lassen - sie sind wie linke und rechte Hand!' :
                'Achirale Molek√ºle lassen sich durch Drehung und Spiegelung zur Deckung bringen.'}
            </p>
            <button class="continue-btn" onclick="showPhase1()">
              Neues Molek√ºl
            </button>
          </div>
        </div>
      `;
      
      checkSuperposition();
    }

    function transformMoleculeA(type) {
      const display = document.getElementById('molecule-a-display');
      const svg = display.querySelector('svg');
      
      if (!svg) return;
      
      if (type === 'rotate') {
        gameState.moleculeA.rotated = !gameState.moleculeA.rotated;
        svg.classList.add('rotating');
      } else if (type === 'mirror') {
        gameState.moleculeA.mirrored = !gameState.moleculeA.mirrored;
        svg.classList.add('flipping');
      }
      
      setTimeout(() => {
        const transformed = applyTransformations(
          gameState.currentMolecule.groups,
          gameState.moleculeA.rotated,
          gameState.moleculeA.mirrored
        );
        display.innerHTML = createTetrahedralMolecule(transformed, false, false);
        checkSuperposition();
      }, 800);
    }

    function resetMoleculeA() {
      gameState.moleculeA = { rotated: false, mirrored: false };
      document.getElementById('molecule-a-display').innerHTML = 
        createTetrahedralMolecule(gameState.currentMolecule.groups, false, false);
      checkSuperposition();
    }

    function transformMoleculeB(type) {
      const display = document.getElementById('molecule-b-display');
      const svg = display.querySelector('svg');
      
      if (!svg) return;
      
      if (type === 'rotate') {
        gameState.moleculeB.rotated = !gameState.moleculeB.rotated;
        svg.classList.add('rotating');
      } else if (type === 'mirror') {
        gameState.moleculeB.mirrored = !gameState.moleculeB.mirrored;
        svg.classList.add('flipping');
      }
      
      setTimeout(() => {
        const transformed = applyTransformations(
          window.moleculeBOriginal,
          gameState.moleculeB.rotated,
          gameState.moleculeB.mirrored
        );
        display.innerHTML = createTetrahedralMolecule(transformed, false, false);
        checkSuperposition();
      }, 800);
    }

    function resetMoleculeB() {
      gameState.moleculeB = { rotated: false, mirrored: false };
      document.getElementById('molecule-b-display').innerHTML = 
        createTetrahedralMolecule(window.moleculeBOriginal, false, false);
      checkSuperposition();
    }

    function checkSuperposition() {
      const transformedA = applyTransformations(
        gameState.currentMolecule.groups,
        gameState.moleculeA.rotated,
        gameState.moleculeA.mirrored
      );
      
      const transformedB = applyTransformations(
        window.moleculeBOriginal,
        gameState.moleculeB.rotated,
        gameState.moleculeB.mirrored
      );
      
      const resultArea = document.getElementById('result-area');
      
      if (areIdentical(transformedA, transformedB)) {
        if (gameState.currentMolecule.isChiral) {
          // Bei chiralen Molek√ºlen sollten Enantiomere NICHT deckungsgleich sein
          resultArea.innerHTML = `
            <div class="feedback" style="background: #fed7d7; border: 3px solid #f56565; color: #742a2a;">
              <h3>‚ö†Ô∏è Achtung!</h3>
              <p>Du hast die Molek√ºle zur Deckung gebracht, aber das sollte bei echten Enantiomeren eigentlich nicht m√∂glich sein. Enantiomere sind Spiegelbildisomere, die sich wie linke und rechte Hand verhalten!</p>
            </div>
          `;
        } else {
          resultArea.innerHTML = `
            <div class="success-message">
              ‚úÖ Perfekt! Die Molek√ºle sind deckungsgleich - es ist das GLEICHE Molek√ºl!
            </div>
          `;
        }
      } else {
        if (gameState.currentMolecule.isChiral) {
          resultArea.innerHTML = `
            <div class="feedback" style="background: #bee3f8; border: 3px solid #3182ce; color: #1a365d;">
              <h3>üëç Weiter probieren!</h3>
              <p>Enantiomere lassen sich nicht zur Deckung bringen - sie sind Spiegelbildisomere!</p>
            </div>
          `;
        } else {
          resultArea.innerHTML = '';
        }
      }
    }

    window.checkAnswer = checkAnswer;
    window.showPhase2 = showPhase2;
    window.transformMoleculeA = transformMoleculeA;
    window.resetMoleculeA = resetMoleculeA;
    window.transformMoleculeB = transformMoleculeB;
    window.resetMoleculeB = resetMoleculeB;

    async function onConfigChange(config) {
      document.getElementById('game-title').textContent = 
        config.game_title || defaultConfig.game_title;
      
      const primaryColor = config.primary_color || defaultConfig.primary_color;
      const secondaryColor = config.secondary_color || defaultConfig.secondary_color;
      
      document.querySelectorAll('.answer-btn').forEach(btn => {
        btn.style.background = primaryColor;
      });
      
      document.querySelectorAll('.phase-indicator').forEach(indicator => {
        indicator.style.background = primaryColor;
      });
      
      document.querySelectorAll('.transform-btn').forEach(btn => {
        if (!btn.textContent.includes('Zur√ºcksetzen')) {
          btn.style.background = secondaryColor;
        }
      });
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [
            {
              get: () => config.primary_color || defaultConfig.primary_color,
              set: (value) => {
                window.elementSdk.config.primary_color = value;
                window.elementSdk.setConfig({ primary_color: value });
              }
            },
            {
              get: () => config.secondary_color || defaultConfig.secondary_color,
              set: (value) => {
                window.elementSdk.config.secondary_color = value;
                window.elementSdk.setConfig({ secondary_color: value });
              }
            },
            {
              get: () => config.success_color || defaultConfig.success_color,
              set: (value) => {
                window.elementSdk.config.success_color = value;
                window.elementSdk.setConfig({ success_color: value });
              }
            }
          ],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ["game_title", config.game_title || defaultConfig.game_title],
          ["phase1_instruction", config.phase1_instruction || defaultConfig.phase1_instruction],
          ["phase2_instruction", config.phase2_instruction_enantiomers || defaultConfig.phase2_instruction_enantiomers],
          ["chiral_button", config.chiral_button || defaultConfig.chiral_button],
          ["achiral_button", config.achiral_button || defaultConfig.achiral_button]
        ])
      });
    }

    showPhase1();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a6cc35ad29e6e5c',t:'MTc2NDUzMTA2Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
